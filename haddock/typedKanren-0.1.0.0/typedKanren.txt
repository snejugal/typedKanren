-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/SnejUgal/typedKanren#readme</a>
@package typedKanren
@version 0.1.0.0


-- | The very core of miniKanren. So core that it basically deals with
--   unification only. For writing relational programs, you will need
--   <tt><a>Goal</a></tt> as well.
module Kanren.Core

-- | Types that can enter the relational world.
--   
--   Simple types without fields, such as <a>Bool</a> and <a>Int</a>, can
--   be used in relational programs as is. Instances for such types are as
--   simple as
--   
--   <pre>
--   data Ternary = True | False | Maybe deriving (Eq)
--   instance Logical Ternary
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run (\x -&gt; x === Value True)
--   [True]
--   </pre>
--   
--   When a type contains other types, this becomes more tricky. Consider
--   the following type:
--   
--   <pre>
--   data Point = Point { x :: Int, y :: Int }
--   </pre>
--   
--   In the relational world, values may be known only partially. For
--   example, we may find out that some equation is true only for a
--   particular value of <tt>x</tt>, but once that holds, <tt>y</tt> can be
--   anything. The definition above cannot express this, since
--   <tt>Point</tt> has to be instantiated with some particular pair of
--   <tt>Int</tt>s.
--   
--   To account for this, we'd like to modify the definition slightly, so
--   that each field can possibly contain a variable:
--   
--   <pre>
--   data LogicPoint = LogicPoint { logicX :: Term Int, logicY :: Term Int }
--   </pre>
--   
--   <tt><a>Term</a> a</tt> here can either be a <a>Var</a> or a
--   <a>Value</a> for type <tt>a</tt>.
--   
--   Now we can specify that a <tt>Point</tt> becomes a <tt>LogicPoint</tt>
--   in the relational world:
--   
--   <pre>
--   instance Logical Point where
--     type Logic Point = LogicPoint
--   </pre>
--   
--   However, we are not finished here yet. When a type has a different
--   representation in the logical world, we need to show how we can go
--   from a <tt>Point</tt> to a <tt>LogicPoint</tt> with <a>inject</a> and
--   go back with <a>extract</a>:
--   
--   <pre>
--   inject (Point x y) = LogicPoint (Value x) (Value y)
--   extract (LogicPoint (Value x) (Value y)) = Just (Point x y)
--   extract _ = Nothing
--   </pre>
--   
--   Note that while we can always transform a <tt>Point</tt> to a
--   <tt>LogicPoint</tt>, going back to a <tt>Point</tt> can fail if any
--   field contains a variable.
--   
--   We also need to show how <tt>LogicPoint</tt>s can be unified. For
--   simple types, unification of terms works in the following way. If both
--   terms are already known, we just check that they are equal. Otherwise,
--   one of the terms is a variable, and we record that it must be equal to
--   the other term.
--   
--   With complex types, a third case is possible: we can refine an
--   existing value if one of its fields is a variable. We can achieve this
--   by unifying each field separately.
--   
--   <pre>
--   unify (LogicPoint leftX leftY) (LogicPoint rightX rightY) state =
--     unify' leftX rightX state &gt;&gt;= unify' leftY rightY
--   </pre>
--   
--   <a>unify</a> takes two values being unified and the current state. If
--   unification succeeds, a new state with acquired knowledge is returned.
--   if unification leads to contradiction (the two values cannot be
--   unified), <a>unify</a> returns <a>Nothing</a>. You do not modify the
--   state yourself — this is handled by <a>unify'</a>, a version of
--   <a>unify</a> which works on <a>Term</a>s instead of logic values.
--   
--   When we find out that a variable must have a particular value, we need
--   not only to add a new entry in the state, but also update existing
--   values which might contain that variable. This is the job of
--   <a>walk</a>, which takes the value being updated and the current
--   state. Just like with <a>unify</a>, the actual job of replacing
--   variables with values is done by <a>walk'</a>, and you only need to
--   apply it to each field.
--   
--   <pre>
--   walk f (LogicPoint x y) = LogicPoint (walk' f x) (walk' f x)
--   </pre>
--   
--   You may notice that the logical representation of the type and the
--   <a>Logical</a> instance are suitable for automatic generation. Indeed,
--   the <tt><a>GenericLogical</a></tt> module provides generic versions of
--   <a>Logical</a>'s methods. The <tt><a>TH</a></tt> module goes further
--   and provides <a>makeLogic</a> to generate logical representations for
--   your types.
--   
--   Although you'll see instances for <tt>base</tt> types below, keep in
--   mind that they're only available from the <tt><a>LogicalBase</a></tt>
--   module.
class Logical a where {
    
    -- | The logical representation of this type. This defaults to the type
    --   itself, but complex types will usually have a separate logic type.
    --   
    --   Note that 'Logic a' is injective, so two different types cannot use
    --   the same type as their logical representation. If you want to provide
    --   an instance for <tt>newtype NT = NT T</tt>, then the logical
    --   representation should be a newtype as well: <tt>newtype LogicNT =
    --   LogicNT (Logic T)</tt>.
    type Logic a = r | r -> a;
    type Logic a = a;
}

-- | Perform unification of two values. If unification succeeds, return the
--   possibly modified state. If unification leads to contradiction, return
--   <a>Nothing</a>.
--   
--   The default implementation checks for equality, which works well for
--   simple types. Complex types will provide their own implmentations
--   which apply <a>unify'</a> to each field.
unify :: Logical a => Logic a -> Logic a -> State -> Maybe State

-- | Perform unification of two values. If unification succeeds, return the
--   possibly modified state. If unification leads to contradiction, return
--   <a>Nothing</a>.
--   
--   The default implementation checks for equality, which works well for
--   simple types. Complex types will provide their own implmentations
--   which apply <a>unify'</a> to each field.
unify :: (Logical a, Eq (Logic a)) => Logic a -> Logic a -> State -> Maybe State

-- | Update the value with acquired knowledge. This method the current
--   state to substitute variables with their obtained values.
--   
--   The default implementation works for simple types and returns the
--   value as is (since there's nothing to substitute inside). Complex
--   types will provide their own implementations which apply <a>walk'</a>
--   to each field.
walk :: Logical a => State -> Logic a -> Logic a

-- | Update the value with acquired knowledge. This method the current
--   state to substitute variables with their obtained values.
--   
--   The default implementation works for simple types and returns the
--   value as is (since there's nothing to substitute inside). Complex
--   types will provide their own implementations which apply <a>walk'</a>
--   to each field.
walk :: (Logical a, a ~ Logic a) => State -> Logic a -> Logic a
occursCheck :: Logical a => VarId b -> Logic a -> State -> Bool
occursCheck :: (Logical a, a ~ Logic a) => VarId b -> Logic a -> State -> Bool

-- | Transform a value to its logical representation.
--   
--   The default implementation works for simple types and returns the
--   value as is. Complex types will provide their own implementations
--   which apply <a>inject'</a> to each field. <a>inject'</a> is also the
--   function that you will use in your relational programs.
inject :: Logical a => a -> Logic a

-- | Transform a value to its logical representation.
--   
--   The default implementation works for simple types and returns the
--   value as is. Complex types will provide their own implementations
--   which apply <a>inject'</a> to each field. <a>inject'</a> is also the
--   function that you will use in your relational programs.
inject :: (Logical a, a ~ Logic a) => a -> Logic a

-- | Transform a logical representation of a value back to its normal
--   representation. Note that this transformation can fail in the general
--   case, because variables cannot be transformed to values.
--   
--   The default implementation works for simple types and returns the
--   value as is. Complex types will provide their own implementations
--   which apply <a>extract'</a> to each field. <a>extract'</a> is also the
--   function that you will use in your code.
extract :: Logical a => Logic a -> Maybe a

-- | Transform a logical representation of a value back to its normal
--   representation. Note that this transformation can fail in the general
--   case, because variables cannot be transformed to values.
--   
--   The default implementation works for simple types and returns the
--   value as is. Complex types will provide their own implementations
--   which apply <a>extract'</a> to each field. <a>extract'</a> is also the
--   function that you will use in your code.
extract :: (Logical a, a ~ Logic a) => Logic a -> Maybe a

-- | A variable, which reserves a place for a logical value for type
--   <tt>a</tt>.
data VarId a

-- | A logical value for type <tt>a</tt>, or a variable.
--   
--   Note that <tt>a</tt> must be the “normal” type, not its logical
--   representation, since <a>Term</a> stores <tt><a>Logic</a> a</tt>. For
--   example, <tt>Term (Either String (Tree Int))</tt> will correctly use
--   <tt>LogicList Char</tt> and <tt>LogicTree Int</tt> deep inside. This
--   way, you do not need to know what the logic representation for a type
--   is named, and deriving the logical representation for a type is
--   trivial.
data Term a
Var :: !VarId a -> Term a
Value :: !Logic a -> Term a

-- | Treat a type as atomic, i.e. containing no variables inside. This
--   requires <tt>a</tt> only to have an <a>Eq</a> instance, thus ignoring
--   its logical representation if it exists. Useful when you really don't
--   want to look inside something.
--   
--   <pre>
--   type Symbol = Atomic String
--   </pre>
newtype Atomic a
Atomic :: a -> Atomic a

-- | <a>unify</a>, but on <a>Term</a>s instead of <a>Logic</a> values. If
--   new knowledge is obtained during unification, it is obtained here.
unify' :: Logical a => Term a -> Term a -> State -> Maybe State

-- | <a>walk</a>, but on <a>Term</a>s instead of <a>Logic</a> values. The
--   actual substitution of variables with values happens here.
walk' :: Logical a => State -> Term a -> Term a
occursCheck' :: Logical a => VarId b -> Term a -> State -> Bool

-- | <a>inject</a>, but to a <a>Term</a> instead of a <a>Logic</a> value.
--   You will use this function in your relational programs to inject
--   normal values.
--   
--   <pre>
--   run (\x -&gt; x === inject' [1, 2, 3])
--   </pre>
inject' :: Logical a => a -> Term a

-- | <a>extract</a>, but from a <a>Term</a> instead of a <a>Logic</a>
--   value. Note that this transformation can fail in the general case,
--   because variables cannot be transformed to values.
--   
--   You will use this function to transform solutions of a program back to
--   their normal representation.
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (\x -&gt; x === inject' (Left 42 :: Either Int Bool))
--   [Just (Left 42)]
--   </pre>
extract' :: Logical a => Term a -> Maybe a
class (Logical a) => Normalizable a
normalize :: Normalizable a => (forall i. VarId i -> Normalizer (VarId i)) -> Logic a -> Normalizer (Logic a)
normalize :: (Normalizable a, a ~ Logic a) => (forall i. VarId i -> Normalizer (VarId i)) -> Logic a -> Normalizer (Logic a)
normalize' :: Normalizable a => (forall i. VarId i -> Normalizer (VarId i)) -> Term a -> Normalizer (Term a)
runNormalize :: Normalizable a => Term a -> Term a

-- | Add a constraint that two terms must not be equal.
disequality :: Logical a => Term a -> Term a -> State -> Maybe State

-- | One branch in the search tree. Keeps track of known substitutions and
--   variables.
data State

-- | The initial state without any knowledge and variables.
empty :: State

-- | Create a variable in the given state.
makeVariable :: State -> (State, Term a)
instance Control.DeepSeq.NFData (Kanren.Core.VarId a)
instance GHC.Classes.Eq (Kanren.Core.VarId a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Kanren.Core.Atomic a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Kanren.Core.Atomic a)
instance GHC.Base.Functor Kanren.Core.Normalizer
instance GHC.Generics.Generic (Kanren.Core.Term a)
instance GHC.Show.Show Kanren.Core.Subst
instance GHC.Show.Show Kanren.Core.Disequalities
instance GHC.Show.Show Kanren.Core.State
instance Control.DeepSeq.NFData (Kanren.Core.Logic a) => Control.DeepSeq.NFData (Kanren.Core.Term a)
instance GHC.Classes.Eq (Kanren.Core.Logic a) => GHC.Classes.Eq (Kanren.Core.Term a)
instance GHC.Classes.Eq a => Kanren.Core.Normalizable (Kanren.Core.Atomic a)
instance GHC.Show.Show (Kanren.Core.Logic a) => GHC.Show.Show (Kanren.Core.Term a)
instance GHC.IsList.IsList (Kanren.Core.Logic a) => GHC.IsList.IsList (Kanren.Core.Term a)
instance GHC.Num.Num (Kanren.Core.Logic a) => GHC.Num.Num (Kanren.Core.Term a)
instance GHC.Classes.Eq a => Kanren.Core.Logical (Kanren.Core.Atomic a)
instance GHC.Show.Show Kanren.Core.ErasedTerm
instance GHC.Base.Semigroup Kanren.Core.Subst
instance GHC.Base.Applicative Kanren.Core.Normalizer
instance GHC.Base.Monad Kanren.Core.Normalizer
instance GHC.Show.Show a => GHC.Show.Show (Kanren.Core.Atomic a)
instance GHC.Show.Show (Kanren.Core.VarId a)


-- | <a>Generic</a> implementations of <a>Logical</a> methods.
--   
--   As discussed in the documentation for the <a>Logical</a> class, method
--   implementations are not particularly interesting and can be easily
--   automated. This module provides such automated implementations using
--   <a>Generic</a>.
--   
--   This module expects that you already have a logical representation for
--   your type, and there's already a <a>Logic</a> type instance. The
--   logical type must not change the order of constructors as well as the
--   order of fields in each constructor, but the names do not matter.
--   Additionally, each field in the original type must be wrapped in a
--   <a>Term</a> in the logical representation.
--   
--   For example, consider the following type definition:
--   
--   <pre>
--   data Tree a
--     = Leaf a
--     | Node (Tree a) (Tree a)
--     deriving (Generic)
--   
--   data LogicTree a
--     = LogicLeaf (Term a)
--     | LogicNode (Term (Tree a)) (Term (Tree a))
--     deriving (Generic)
--   </pre>
--   
--   From there, using the generic implementations is trivial:
--   
--   <pre>
--   instance (Logical a) =&gt; Logical (Tree a) where
--     type Logic (Tree a) = LogicTree a
--     unify = genericUnify
--     subst = genericSubst
--     inject = genericInject
--     extract = genericExtract
--   </pre>
module Kanren.GenericLogical

-- | The generic implementation of <a>unify</a>.
genericUnify :: forall a. (Generic (Logic a), GLogical (Rep a) (Rep (Logic a))) => Logic a -> Logic a -> State -> Maybe State

-- | The generic implementation of <a>walk</a>.
genericWalk :: forall a. (Generic (Logic a), GLogical (Rep a) (Rep (Logic a))) => State -> Logic a -> Logic a

-- | The generic implementation of <a>walk</a>.
genericOccursCheck :: forall a b. (Generic (Logic a), GLogical (Rep a) (Rep (Logic a))) => VarId b -> Logic a -> State -> Bool

-- | The generic implementation of <a>inject</a>.
genericInject :: (Generic a, Generic (Logic a), GLogical (Rep a) (Rep (Logic a))) => a -> Logic a

-- | The generic implementation of <a>extract</a>.
genericExtract :: (Generic a, Generic (Logic a), GLogical (Rep a) (Rep (Logic a))) => Logic a -> Maybe a
class GLogical f f'
instance Kanren.GenericLogical.GLogical GHC.Generics.V1 GHC.Generics.V1
instance Kanren.GenericLogical.GLogical GHC.Generics.U1 GHC.Generics.U1
instance (Kanren.GenericLogical.GLogical f f', Kanren.GenericLogical.GLogical g g') => Kanren.GenericLogical.GLogical (f GHC.Generics.:+: g) (f' GHC.Generics.:+: g')
instance (Kanren.GenericLogical.GLogical f f', Kanren.GenericLogical.GLogical g g') => Kanren.GenericLogical.GLogical (f GHC.Generics.:*: g) (f' GHC.Generics.:*: g')
instance Kanren.Core.Logical c => Kanren.GenericLogical.GLogical (GHC.Generics.K1 i c) (GHC.Generics.K1 i' (Kanren.Core.Term c))
instance Kanren.GenericLogical.GLogical f f' => Kanren.GenericLogical.GLogical (GHC.Generics.M1 i t f) (GHC.Generics.M1 i' t' f')

module Kanren.Stream
data Stream a
Done :: Stream a
Only :: a -> Stream a
Yield :: a -> Stream a -> Stream a
Await :: Stream a -> Stream a
maybeToStream :: Maybe a -> Stream a
interleave :: Stream a -> Stream a -> Stream a
instance Data.Foldable.Foldable Kanren.Stream.Stream
instance GHC.Base.Functor Kanren.Stream.Stream
instance GHC.Show.Show a => GHC.Show.Show (Kanren.Stream.Stream a)
instance GHC.Base.Applicative Kanren.Stream.Stream
instance GHC.Base.Monad Kanren.Stream.Stream


-- | Implement and execute relational programs.
module Kanren.Goal

-- | A computation in the relational world.
--   
--   On its own, a goal performs search in a search tree. It takes some
--   state and transforms it to a stream of new states. But it is better to
--   think of a goal as a relational program. If you want to write a
--   predicate, it will take <a>Term</a>s as parameters and return a
--   <a>Goal</a>.
--   
--   <pre>
--   zeroo :: Term Int -&gt; Goal ()
--   zeroo x = x === Value 0
--   </pre>
--   
--   A <a>Goal</a> is a <a>Monad</a>, so you can use the do-notation to
--   write relations.
--   
--   <pre>
--   oppositeso :: Term Bool -&gt; Term Bool -&gt; Goal ()
--   oppositeso x y = do
--     x === Value True
--     y === Value False
--   </pre>
--   
--   Sequencing two goals performs <a>conj</a>unction. To make a branch,
--   use <a>disj</a>unction.
--   
--   <pre>
--   noto :: Term Bool -&gt; Term Bool -&gt; Goal ()
--   noto x y = xIsTrue `disj` xIsFalse
--    where
--     xIsTrue = x === Value True `conj` y === Value False
--     xIsFalse = x === Value False `conj` y === Value True
--   </pre>
--   
--   To execute a goal and find its solutions, use <a>run</a>.
--   
--   <pre>
--   &gt;&gt;&gt; run (\x -&gt; noto (Value False) x)
--   [Value True]
--   </pre>
data Goal x

-- | Query for solutions of a goal.
--   
--   <pre>
--   &gt;&gt;&gt; run (\x -&gt; x === Value (42 :: Int))
--   [42]
--   </pre>
--   
--   You can ask to solve for several variables, or none at all. You can
--   still create intermediate variables inside using <a>fresh</a>, but
--   they will not be returned as solutions.
--   
--   <pre>
--   &gt;&gt;&gt; run (\() -&gt; fresh &gt;&gt;= (\x -&gt; x === Value True))
--   [()]
--   </pre>
--   
--   Note that there may be several solutions, including infinitely many or
--   zero. If you want to limit the number of solutions, just put it
--   through <a>take</a>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ run (\x -&gt; disjMany (map (\a -&gt; x === Value a) [0 :: Int ..]))
--   [0,1,2,3,4]
--   </pre>
--   
--   This function will return logical representation of solutions. This
--   matters for complex types which have a separate logical
--   representation. If you want to transform them back to regular
--   representation, use <a>fmap</a> and <a>extract'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (\x -&gt; x === inject' [True])
--   [Just [True]]
--   </pre>
--   
--   Note that the retrived solutions might be subject to constraints, but
--   it is not yet possible to retrieve them.
run :: Fresh v => (v -> Goal ()) -> [v]

-- | A goal that always succeeds.
--   
--   <pre>
--   &gt;&gt;&gt; run (\() -&gt; successo ())
--   [()]
--   </pre>
successo :: x -> Goal x

-- | A goal that always fails.
--   
--   <pre>
--   &gt;&gt;&gt; run (\() -&gt; failo)
--   []
--   </pre>
failo :: Goal x

-- | Unify two terms.
--   
--   <pre>
--   &gt;&gt;&gt; run (\() -&gt; Value 42 === Value (42 :: Int))
--   [()]
--   
--   &gt;&gt;&gt; run (\() -&gt; Value 42 === Value (37 :: Int))
--   []
--   </pre>
(===) :: Logical a => Term a -> Term a -> Goal ()
infix 4 ===

-- | Perform conjnction of two goals. If the first goal succeeds, run the
--   second goal on its results.
--   
--   <pre>
--   &gt;&gt;&gt; run (\x -&gt; x === Value 42 `conj` x === Value (42 :: Int))
--   [42]
--   
--   &gt;&gt;&gt; run (\x -&gt; x === Value 42 `conj` x === Value (37 :: Int))
--   []
--   
--   &gt;&gt;&gt; run (\(x, y) -&gt; x === Value (42 :: Int) `conj` y === Value True)
--   [(42,True)]
--   </pre>
--   
--   Note that the do-notation performs conjunction as well, so you will
--   rarely need to use this function directly.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    run (\(x, y) -&gt; do
--      x === Value (42 :: Int)
--      y === Value True
--    )
--   :}
--   [(42,True)]
--   </pre>
conj :: Goal x -> Goal y -> Goal y
infixr 3 `conj`

-- | Perform conjunction of several goals, left to right.
--   
--   <pre>
--   &gt;&gt;&gt; run (\(x, y) -&gt; conjMany [x === Value (42 :: Int), y === Value True])
--   [(42,True)]
--   </pre>
conjMany :: [Goal ()] -> Goal ()

-- | Perform disjunction of two goals. Run the first goal, then the second,
--   and combine their results.
--   
--   <pre>
--   &gt;&gt;&gt; run (\x -&gt; x === Value 42 `disj` x === Value (37 :: Int))
--   [42,37]
--   
--   &gt;&gt;&gt; run (\x -&gt; x === Value 42 `disj` x === Value (42 :: Int))
--   [42,42]
--   
--   &gt;&gt;&gt; run (\(x, y) -&gt; x === Value (42 :: Int) `disj` y === Value True)
--   [(42,_.0),(_.1,True)]
--   </pre>
disj :: Goal x -> Goal x -> Goal x
infixr 2 `disj`

-- | Perform disjunction of several goals, left to right.
--   
--   <pre>
--   &gt;&gt;&gt; run (\x -&gt; disjMany (map (\a -&gt; x === Value a) [1, 3 .. 11 :: Int]))
--   [1,3,5,7,9,11]
--   </pre>
disjMany :: [Goal x] -> Goal x

-- | Consider several possible cases, using syntax similar to
--   <tt>conde</tt> from <tt>faster-minikanren</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     run (\(x, y) -&gt; conde
--       [ [ x === Value False, y === Value 0 ]
--       , [ x === Value True, y === Value 1 ]
--       ])
--   :}
--   [(False,0),(True,1)]
--   </pre>
--   
--   However, this might not be the best syntax for Haskell. Using
--   <a>disjMany</a> with the do-notation may be easier to type and less
--   noisy:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     run (\(x, y) -&gt; disjMany
--       [ do
--           x === Value False
--           y === Value 0
--       , do
--           x === Value True
--           y === Value 1
--       ])
--   :}
--   [(False,0),(True,1)]
--   </pre>
--   
--   In addition, the <a>Match</a> module provides pattern matching over
--   variants, which might better express your intent.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     run (\(x, y) -&gt; x &amp; (matche
--       &amp; on _False (\() -&gt; y === Value 0)
--       &amp; on _True (\() -&gt; y === Value 1)))
--   :}
--   [(False,0),(True,1)]
--   </pre>
conde :: [[Goal ()]] -> Goal ()
delay :: Goal a -> Goal a

-- | Put a constraint that two terms must not be equal.
--   
--   <pre>
--   &gt;&gt;&gt; run (\x -&gt; x =/= Value 42 `conj` x === Value (37 :: Int))
--   [37]
--   
--   &gt;&gt;&gt; run (\x -&gt; x =/= Value 42 `conj` x === Value (42 :: Int))
--   []
--   </pre>
--   
--   It is not yet possible to retrieve solutions along with remaining
--   constraints.
(=/=) :: Logical a => Term a -> Term a -> Goal ()
infix 4 =/=

-- | The existential quantifier.
--   
--   Whenever you need an intermediate variable, <a>fresh</a> will give you
--   one.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     run (\() -&gt; do
--       x &lt;- fresh
--       x === Value (42 :: Int))
--   :}
--   [()]
--   </pre>
--   
--   Creating a lot of variables one-by-one might be tiresome though. This
--   is why <a>fresh</a> is not a standalone function but a method on a
--   type class. <a>Fresh</a> is implemented not only for <tt><a>Term</a>
--   a</tt> but for tuples too, so you can ask for several fresh variables
--   at once.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     run (\() -&gt; do
--       (x, y) &lt;- fresh
--       x === Value True
--       y === Value False)
--   :}
--   [()]
--   </pre>
--   
--   In fact, <a>run</a> also uses <a>Fresh</a>, so you can choose how many
--   variables you want to solve for.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     run (\(x, y) -&gt; do
--       x === Value True
--       y === Value False)
--   :}
--   [(True,False)]
--   </pre>
--   
--   As an edge case, you can ask for no variables at all using
--   <tt>()</tt>. While this is not useful inside relations, this is how
--   the first two examples actually work. <a>Fresh</a> is also used for
--   pattern matching from the <tt><a>Match</a></tt> module when the
--   matched value is not known yet.
class Fresh v

-- | Create fresh variables.
fresh' :: Fresh v => Goal v

-- | Resolve each variable to its value in the given state.
resolve :: Fresh v => State -> v -> v
fresh :: Fresh v => Goal v
instance Kanren.Goal.Fresh ()
instance Kanren.Core.Logical a => Kanren.Goal.Fresh (Kanren.Core.Term a)
instance (Kanren.Goal.Fresh a, Kanren.Goal.Fresh b) => Kanren.Goal.Fresh (a, b)
instance (Kanren.Goal.Fresh a, Kanren.Goal.Fresh b, Kanren.Goal.Fresh c) => Kanren.Goal.Fresh (a, b, c)
instance (Kanren.Goal.Fresh a, Kanren.Goal.Fresh b, Kanren.Goal.Fresh c, Kanren.Goal.Fresh d) => Kanren.Goal.Fresh (a, b, c, d)
instance (Kanren.Goal.Fresh a, Kanren.Goal.Fresh b, Kanren.Goal.Fresh c, Kanren.Goal.Fresh d, Kanren.Goal.Fresh e) => Kanren.Goal.Fresh (a, b, c, d, e)
instance (Kanren.Goal.Fresh a, Kanren.Goal.Fresh b, Kanren.Goal.Fresh c, Kanren.Goal.Fresh d, Kanren.Goal.Fresh e, Kanren.Goal.Fresh f) => Kanren.Goal.Fresh (a, b, c, d, e, f)
instance GHC.Base.Functor Kanren.Goal.Goal
instance GHC.Base.Applicative Kanren.Goal.Goal
instance GHC.Base.Monad Kanren.Goal.Goal
instance GHC.Base.Alternative Kanren.Goal.Goal


-- | The <tt>matche</tt> for Haskell. Comes in non-exhaustive and, most
--   importantly, exhaustive versions.
module Kanren.Match

-- | One case for non-exhaustive pattern matching.
--   
--   Although we try to match on a <a>Term</a>, the prism only need to
--   operate on a <a>Logic</a> type.
--   
--   In case when the value being match is unknown yet, <a>on</a> must be
--   able to construct this value from the pattern — hence the
--   <tt><a>Fresh</a> v</tt> constraint. It should just work though since
--   <a>Fresh</a> has instances for tuples, and prisms' foci are tuples
--   too.
on :: (Logical a, Fresh v) => Prism' (Logic a) v -> (v -> Goal x) -> (Term a -> Goal x) -> Term a -> Goal x

-- | Finalize non-exhaustive pattern matching.
matche :: Term a -> Goal x

-- | Focus on the logical value inside a term.
--   
--   This prism aids nested pattern matching. You might expect that, since
--   regular prisms can be easily composed, say <tt><a>_Just</a> .
--   <a>_Left</a></tt>, then <tt><a>_LogicJust</a> . <a>_LogicLeft</a></tt>
--   should also work. However, this is not the case since the types are
--   slightly different:
--   
--   <pre>
--   _LogicJust :: Prism' (Logic (Maybe (Either a b))) (Term (Either a b))
--   _LogicLeft :: Prism'                             (Logic (Either a b)) (Term a)
--   </pre>
--   
--   Hence, we need one more prism between <a>_LogicJust</a> and
--   <a>_LogicLeft</a> for the types to match. This prism is <a>_Value</a>.
_Value :: Prism' (Term a) (Logic a)

-- | Begin exhaustive pattern matching by attaching initial tags to the
--   term. Do keep in mind that these tags do not exist at runtime.
enter' :: (Matched m a -> Goal x) -> Term a -> Goal x

-- | One case for exhaustive pattern matching.
--   
--   Exhaustive pattern matching requires special prisms which know of all
--   possible variants and can mark a variant as checked. See the guide
--   above for details.
--   
--   <tt>Remaining</tt> and <tt>Checked</tt> are private types on purpose.
on' :: (Logical a, Fresh v) => ExhaustivePrism (Logic a) m m' v Remaining Checked -> (v -> Goal x) -> (Matched m' a -> Goal x) -> Matched m a -> Goal x

-- | Finalize exhaustive pattern matching.
--   
--   The <tt>Exhausted m</tt> constraint checks that <tt>m</tt> is composed
--   only of <tt>Checked</tt> tags.
--   
--   <pre>
--   instance Exhaustive Checked
--   instance (Exhaustive a, Exhaustive b) =&gt; Exhaustive (a, b)
--   ...
--   </pre>
matche' :: Exhausted m => Matched m a -> Goal x

-- | A prism which is suitable for exhaustive pattern matching.
--   
--   Although the type definition might allow changing the type of the
--   focus, this is not neccesary for exhaustive pattern matching and so
--   not covered here.
type ExhaustivePrism s m m' a t t' = Prism (Tagged m s) (Tagged m' s) (Tagged t a) (Tagged t' a)

-- | The isomorphism for <a>Tagged</a>, useful to implement prisms for
--   exhaustive pattern matching.
--   
--   <pre>
--   _LogicJust' :: Prism
--     (Tagged (nothing, just ) (Maybe a ))
--     (Tagged (nothing, just') (Maybe a'))
--     (Tagged just  (Term a ))
--     (Tagged just' (Term a'))
--   _LogicJust' = from _Tagged . _LogicJust . _Tagged
--   </pre>
_Tagged :: Iso b b' (Tagged s b) (Tagged s' b')

-- | Focus on the logical value inside a term.
--   
--   This prism serves the same purpose as <a>_Value</a>, but is adapted
--   for exhaustive pattern matching.
_Value' :: ExhaustivePrism (Term a) m m' (Logic a) m m'
instance Kanren.Match.Exhausted Kanren.Match.Checked
instance (Kanren.Match.Exhausted a, Kanren.Match.Exhausted b) => Kanren.Match.Exhausted (a, b)
instance (Kanren.Match.Exhausted a, Kanren.Match.Exhausted b, Kanren.Match.Exhausted c) => Kanren.Match.Exhausted (a, b, c)
instance (Kanren.Match.Exhausted a, Kanren.Match.Exhausted b, Kanren.Match.Exhausted c, Kanren.Match.Exhausted d) => Kanren.Match.Exhausted (a, b, c, d)


-- | Automatic generation of logic types.
module Kanren.TH

-- | Generate a logic representation and a corresponding <a>Logical</a>
--   instance for a given type.
--   
--   Using this function requires you to enable the <tt>DeriveGeneric</tt>
--   and <tt>TypeFamilies</tt> extensions.
--   
--   Consider the following type definition:
--   
--   <pre>
--   data Tree a
--     = Empty
--     | Leaf a
--     | Tree a :* Tree a
--   </pre>
--   
--   <tt>makeLogical ''Tree</tt> yields
--   
--   <pre>
--   data LogicTree a
--     = LogicEmpty
--     | LogicLeaf (Term a)
--     | Term (Tree a) :?* Term (Tree a)
--     deriving (Generic)
--   
--   instance Logical a =&gt; Logical (Tree a) where
--     type Logic (Tree a) = LogicTree a
--     unify = genericUnify
--     walk = genericWalk
--     occursCheck = genericOccursCheck
--     inject = genericInject
--     extract = genericExtract
--   </pre>
--   
--   For details, see <a>makeLogicType</a> and <a>makeLogicalInstance</a>.
makeLogical :: Name -> Q [Dec]

-- | Generate a logic representation and a corresponding <a>Logical</a>
--   instance for each given type. This works like <a>makeLogical</a>, but
--   better suits mutually recursive types.
makeLogicals :: [Name] -> Q [Dec]

-- | Generate a logic representation for a given type.
--   
--   Consider the following type definition:
--   
--   <pre>
--   data Tree a
--     = Empty
--     | Leaf a
--     | Tree a :* Tree a
--   </pre>
--   
--   <tt>makeLogicType ''Tree</tt> yields
--   
--   <pre>
--   data LogicTree a
--     = LogicEmpty
--     | LogicLeaf (Term a)
--     | Term (Tree a) :?* Term (Tree a)
--   </pre>
--   
--   For <tt>newtype</tt>s, it doesn't make sense to introduce another
--   layer of variables. Hence, <a>Logic</a> will be used instead of
--   <a>Term</a>.
--   
--   <pre>
--   newtype BetterInt = BetterInt Int
--   makeLogicType ''BetterInt
--   -- ^ newtype LogicBetterInt = LogicBetterInt (Logic Int)
--   </pre>
makeLogicType :: Name -> Q [Dec]

-- | Generate a logic representation for several types. This works like
--   <a>makeLogicType</a>, but better suits mutually recursive types.
makeLogicTypes :: [Name] -> Q [Dec]

-- | Settings for generating a type's logic representation.
data LogicTypeRules

-- | Default <a>LogicTypeRules</a>. Does not derive any instances for the
--   logical representation.
defaultLogicTypeRules :: LogicTypeRules

-- | <a>makeLogicType</a>, but allows configuring how the logical
--   representation is generated.
makeLogicTypeWith :: LogicTypeRules -> Name -> Q [Dec]

-- | <a>makeLogicTypes</a>, but allows configuring how the logical
--   representations are generated.
makeLogicTypesWith :: LogicTypeRules -> [Name] -> Q [Dec]

-- | Generate a <a>Logical</a> instance, given a type and its logical
--   representation.
--   
--   Currently, the instance relies on <tt><a>GenericLogical</a></tt>, so
--   both types need to have a <a>Generic</a> instance. When using
--   <a>makeLogical</a>, the logical representation will have a derived
--   <a>Generic</a> instance.
--   
--   For each type variable, there will be a <a>Logical</a> constraint.
--   
--   Since <a>Logical</a> includes a type family definition, using this
--   function requires enabling the <tt>TypeFamilies</tt> extension.
--   
--   Consider the following declarations:
--   
--   <pre>
--   data Tree a
--     = Empty
--     | Leaf a
--     | Tree a :* Tree a
--     deriving (Generic)
--   makeLogicType ''Tree
--   deriving instance Generic (LogicTree a)
--   </pre>
--   
--   <tt>makeLogicalInstance ''Tree ''LogicTree</tt> yields
--   
--   <pre>
--   instance Logical a =&gt; Logical (Tree a) where
--     type Logic (Tree a) = LogicTree a
--     unify = genericUnify
--     walk = genericWalk
--     occursCheck = genericOccursCheck
--     inject = genericInject
--     extract = genericExtract
--   </pre>
makeLogicalInstance :: Name -> Name -> Q [Dec]

-- | Generate <a>Logical</a> instances, given pairs of a type and its
--   logical representation. This works like <a>makeLogicalInstance</a>,
--   but better suits mutually recursive types.
makeLogicalInstances :: [(Name, Name)] -> Q [Dec]

-- | Generate <a>ExhaustivePrism</a>s for a given (supposedly logic) type.
--   
--   This function expects that you already have regular prisms in the
--   scope whose names are constructor names prefixed with <tt>_</tt> (i.e.
--   you used <a>makePrisms</a>). Then, exhaustive prisms will have a prime
--   in the end (or an exclamation mark for infix constructors).
--   
--   Consider the following declarations:
--   
--   <pre>
--   data Tree a
--     = Empty
--     | Leaf a
--     | Tree a :* Tree a
--     deriving (Generic)
--   makeLogicType ''Tree
--   makePrisms ''LogicTree
--   </pre>
--   
--   <tt>makeExhaustivePrisms ''LogicTree</tt> yields (sans short tags)
--   
--   <pre>
--   _LogicEmpty' :: ExhaustivePrism (LogicTree a) (e, l, n) (e', l, n) () e e'
--   _LogicEmpty' = from _Tagged . _LogicEmpty . _Tagged
--   
--   _LogicLeaf' :: ExhaustivePrism (LogicTree a) (e, l, n) (e, l', n) (Term a) l l'
--   _LogicLeaf' = from _Tagged . _LogicLeaf . _Tagged
--   
--   (.:?*!) :: ExhaustivePrism (LogicTree a) (e, l, n) (e, l, n') (Term (Tree a), Term (Tree a)) n n'
--   (.:?*!) = from _Tagged . (.:?*) . _Tagged
--   </pre>
makeExhaustivePrisms :: Name -> Q [Dec]


-- | Logical representations for some <tt>base</tt> types along with their
--   (orphan) <a>Logical</a> instances.
module Kanren.LogicalBase
_False :: Prism' Bool ()
_True :: Prism' Bool ()
_False' :: ExhaustivePrism Bool (false, true) (false', true) () false false'
_True' :: ExhaustivePrism Bool (false, true) (false, true') () true true'
data LogicList a
LogicNil :: LogicList a
LogicCons :: Term a -> Term [a] -> LogicList a
_LogicNil :: forall a_atmL. Prism' (LogicList a_atmL) ()
_LogicCons :: forall a_atF0 a_atmL. Prism (LogicList a_atF0) (LogicList a_atmL) (Term a_atF0, Term [a_atF0]) (Term a_atmL, Term [a_atmL])
_LogicNil' :: ExhaustivePrism (LogicList a_atmL) (logicNil, logicCons) (logicNil', logicCons) () logicNil logicNil'
_LogicCons' :: ExhaustivePrism (LogicList a_atmL) (logicNil, logicCons) (logicNil, logicCons') (Term a_atmL, Term [a_atmL]) logicCons logicCons'
data LogicMaybe (a_11 :: Type)
LogicNothing :: LogicMaybe (a_11 :: Type)
LogicJust :: Term a_11 -> LogicMaybe (a_11 :: Type)
_LogicNothing :: forall a_11. Prism' (LogicMaybe a_11) ()
_LogicJust :: forall a_atPD a_11. Prism (LogicMaybe a_atPD) (LogicMaybe a_11) (Term a_atPD) (Term a_11)
_LogicNothing' :: ExhaustivePrism (LogicMaybe a_11) (logicNothing, logicJust) (logicNothing', logicJust) () logicNothing logicNothing'
_LogicJust' :: ExhaustivePrism (LogicMaybe a_11) (logicNothing, logicJust) (logicNothing, logicJust') (Term a_11) logicJust logicJust'
data LogicEither (a_an1X :: Type) (b_an1Y :: Type)
LogicLeft :: Term a_an1X -> LogicEither (a_an1X :: Type) (b_an1Y :: Type)
LogicRight :: Term b_an1Y -> LogicEither (a_an1X :: Type) (b_an1Y :: Type)
_LogicLeft :: forall a_au2V b_an1Y a_an1X. Prism (LogicEither a_au2V b_an1Y) (LogicEither a_an1X b_an1Y) (Term a_au2V) (Term a_an1X)
_LogicRight :: forall a_an1X b_au30 b_an1Y. Prism (LogicEither a_an1X b_au30) (LogicEither a_an1X b_an1Y) (Term b_au30) (Term b_an1Y)
_LogicLeft' :: ExhaustivePrism (LogicEither a_an1X b_an1Y) (logicLeft, logicRight) (logicLeft', logicRight) (Term a_an1X) logicLeft logicLeft'
_LogicRight' :: ExhaustivePrism (LogicEither a_an1X b_an1Y) (logicLeft, logicRight) (logicLeft, logicRight') (Term b_an1Y) logicRight logicRight'
instance (GHC.Classes.Eq (Kanren.Core.Logic a), GHC.Classes.Eq (Kanren.Core.Logic b)) => GHC.Classes.Eq (Kanren.LogicalBase.LogicEither a b)
instance (GHC.Show.Show (Kanren.Core.Logic a), GHC.Show.Show (Kanren.Core.Logic b)) => GHC.Show.Show (Kanren.LogicalBase.LogicEither a b)
instance GHC.Generics.Generic (Kanren.LogicalBase.LogicEither a b)
instance (Kanren.Core.Logical a, Kanren.Core.Logical b) => Kanren.Core.Logical (Data.Either.Either a b)
instance GHC.Classes.Eq (Kanren.Core.Logic a) => GHC.Classes.Eq (Kanren.LogicalBase.LogicMaybe a)
instance GHC.Show.Show (Kanren.Core.Logic a) => GHC.Show.Show (Kanren.LogicalBase.LogicMaybe a)
instance GHC.Generics.Generic (Kanren.LogicalBase.LogicMaybe a)
instance Kanren.Core.Logical a => Kanren.Core.Logical (GHC.Maybe.Maybe a)
instance GHC.Generics.Generic (Kanren.LogicalBase.LogicList a)
instance GHC.Classes.Eq (Kanren.Core.Logic a) => GHC.Classes.Eq (Kanren.LogicalBase.LogicList a)
instance Control.DeepSeq.NFData (Kanren.Core.Logic a) => Control.DeepSeq.NFData (Kanren.LogicalBase.LogicList a)
instance GHC.Show.Show (Kanren.Core.Logic a) => GHC.Show.Show (Kanren.LogicalBase.LogicList a)
instance Kanren.Core.Logical a => Kanren.Core.Logical [a]
instance GHC.IsList.IsList (Kanren.LogicalBase.LogicList a)
instance (Kanren.Core.Logical a, Kanren.Core.Logical b) => Kanren.Core.Logical (a, b)
instance Kanren.Core.Logical GHC.Types.Int
instance Kanren.Core.Logical GHC.Types.Char
instance Kanren.Core.Logical GHC.Base.Void
instance Kanren.Core.Logical GHC.Types.Bool

module Kanren.Example.List
example :: IO ()

module Kanren.Example.Tree
example :: IO ()
instance GHC.Generics.Generic (Kanren.Example.Tree.LogicTree a)
instance Kanren.Core.Logical a => Kanren.Core.Logical (Kanren.Example.Tree.Tree a)
instance GHC.Generics.Generic (Kanren.Example.Tree.Tree a)
instance GHC.Show.Show a => GHC.Show.Show (Kanren.Example.Tree.Tree a)

module Kanren.Example.Matche
example :: IO ()
eithero' :: (Logical a, Logical b) => Term (Either a b) -> Goal ()
instance GHC.Generics.Generic Kanren.Example.Matche.LogicNat
instance Kanren.Core.Logical Kanren.Example.Matche.Nat
instance GHC.Generics.Generic Kanren.Example.Matche.Nat
instance GHC.Show.Show Kanren.Example.Matche.Nat

module Kanren.Data.Scheme
type Symbol = Atomic String
type Env = [(Symbol, Value)]
data SExpr
SSymbol :: Symbol -> SExpr
SNil :: SExpr
SCons :: SExpr -> SExpr -> SExpr
data LogicSExpr
LogicSSymbol :: Term Symbol -> LogicSExpr
LogicSNil :: LogicSExpr
LogicSCons :: Term SExpr -> Term SExpr -> LogicSExpr
data Value
SExpr :: SExpr -> Value
Closure :: Symbol -> SExpr -> Env -> Value
data LogicValue
LogicSExpr :: Term SExpr -> LogicValue
LogicClosure :: Term Symbol -> Term SExpr -> Term Env -> LogicValue
evalo :: Term SExpr -> Term Env -> Term Value -> Goal ()
instance Control.DeepSeq.NFData Kanren.Data.Scheme.LogicSExpr
instance Kanren.Core.Normalizable Kanren.Data.Scheme.SExpr
instance GHC.Show.Show Kanren.Data.Scheme.LogicSExpr
instance GHC.Show.Show Kanren.Data.Scheme.LogicValue
instance GHC.Generics.Generic Kanren.Data.Scheme.LogicValue
instance Kanren.Core.Logical Kanren.Data.Scheme.Value
instance GHC.Generics.Generic Kanren.Data.Scheme.LogicSExpr
instance Kanren.Core.Logical Kanren.Data.Scheme.SExpr
instance Control.DeepSeq.NFData Kanren.Data.Scheme.SExpr
instance GHC.Generics.Generic Kanren.Data.Scheme.SExpr
instance GHC.Classes.Eq Kanren.Data.Scheme.SExpr
instance Control.DeepSeq.NFData Kanren.Data.Scheme.Value
instance GHC.Generics.Generic Kanren.Data.Scheme.Value
instance GHC.Classes.Eq Kanren.Data.Scheme.Value
instance GHC.Show.Show Kanren.Data.Scheme.Value
instance GHC.Show.Show Kanren.Data.Scheme.SExpr
instance GHC.IsList.IsList Kanren.Data.Scheme.SExpr
instance Data.String.IsString Kanren.Data.Scheme.SExpr


-- | This module implements binary numbers as described in the declarative
--   pearl “Pure, Declarative, and Constructive Arithmetic Relations” by O.
--   Kiselyov <i>et al</i>.
--   
--   The paper is available at
--   <a>https://okmij.org/ftp/Prolog/Arithm/arithm.pdf</a> and the original
--   implementation in Prolog is available at
--   <a>https://okmij.org/ftp/Prolog/Arithm/pure-bin-arithm.prl</a>.
module Kanren.Data.Binary
data Bit
O :: Bit
I :: Bit
_O :: Prism' Bit ()
_I :: Prism' Bit ()
_O' :: ExhaustivePrism Bit (o, i) (o', i) () o o'
_I' :: ExhaustivePrism Bit (o, i) (o, i') () i i'
type Binary = [Bit]

-- | Check that the number is zero.
zeroo :: Term Binary -> Goal ()

-- | Check that the number is positive, i.e. greater than zero.
poso :: Term Binary -> Goal ()

-- | Check that the number is greater than one (i.e. at least two).
--   
--   The naming comes from the paper.
gtlo :: Term Binary -> Goal ()

-- | Generate valid binary numbers.
binaryo :: Term Binary -> Goal ()

-- | Calculate the sum <tt>c</tt> of two numbers <tt>a</tt> and <tt>b</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (addo (inject' 3) (inject' 5))
--   [Just [O,O,O,I]]
--   </pre>
--   
--   One can turn it around to subtract from a number:
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (\b -&gt; addo (inject' 2) b (inject' 8))
--   [Just [O,I,I]]
--   </pre>
--   
--   When both summands are unknown, every possible pair will be
--   enumerated.
--   
--   <pre>
--   &gt;&gt;&gt; bimap extract' extract' &lt;$&gt; run (\(a, b) -&gt; addo a b (inject' 2))
--   [(Just [O,I],Just []),(Just [],Just [O,I]),(Just [I],Just [I])]
--   </pre>
--   
--   If one of the summands is greater than the sum, the relation will
--   produce no results.
--   
--   <pre>
--   &gt;&gt;&gt; run (\a -&gt; addo a (inject' 10) (inject' 3))
--   []
--   </pre>
--   
--   The implementation of <tt>add</tt> is discussed in section 4 of the
--   paper.
addo :: Term Binary -> Term Binary -> Term Binary -> Goal ()

-- | Calculate the difference <tt>c</tt> of two numbers <tt>a</tt> and
--   <tt>b</tt>. This is just <a>addo</a>, but with parameters in different
--   order.
subo :: Term Binary -> Term Binary -> Term Binary -> Goal ()

-- | Check that <tt>a</tt> is strictly less than <tt>b</tt>. Otherwise, the
--   goal fails.
--   
--   <pre>
--   &gt;&gt;&gt; run (\() -&gt; lesso (inject' 3) (inject' 4))
--   [()]
--   
--   &gt;&gt;&gt; run (\() -&gt; lesso (inject' 3) (inject' 2))
--   []
--   </pre>
--   
--   One can turn this relation around to generate numbers less or greater
--   than a given one.
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (\x -&gt; lesso x (inject' 4))
--   [Just [],Just [I],Just [I,I],Just [O,I]]
--   
--   &gt;&gt;&gt; take 5 $ extract' &lt;$&gt; run (\x -&gt; lesso (inject' 4) x)
--   [Just [I,O,I],Just [O,I,I],Just [I,I,I],Just [O,O,O,I],Just [I,O,O,I]]
--   </pre>
lesso :: Term Binary -> Term Binary -> Goal ()

-- | Calculate the product <tt>c</tt> of two numbers <tt>a</tt> and
--   <tt>b</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (mulo (inject' 3) (inject' 4))
--   [Just [O,O,I,I]]
--   </pre>
--   
--   One can turn this around to factor a given number.
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (\a -&gt; mulo a (inject' 2) (inject' 12))
--   [Just [O,I,I]]
--   
--   &gt;&gt;&gt; bimap extract' extract' &lt;$&gt; run (\(a, b) -&gt; mulo a b (inject' 4))
--   [(Just [I],Just [O,O,I]),(Just [O,I],Just [O,I]),(Just [O,O,I],Just [I])]
--   </pre>
--   
--   The goal will fail if any multiplier is not a factor of the product.
--   
--   <pre>
--   &gt;&gt;&gt; run (\a -&gt; mulo a (inject' 5) (inject' 7))
--   []
--   </pre>
--   
--   The implementation of <tt>mul</tt> is discussed in section 5 of the
--   paper.
mulo :: Term Binary -> Term Binary -> Term Binary -> Goal ()

-- | Calculate the quotient <tt>q</tt> and remainder <tt>r</tt> of dividing
--   <tt>n</tt> by <tt>m</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; bimap extract' extract' &lt;$&gt; run (\(q, r) -&gt; divo (inject' 17) (inject' 5) q r)
--   [(Just [I,I],Just [O,I])]
--   </pre>
--   
--   One can turn this around to find divisors of a number.
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (\m -&gt; fresh &gt;&gt;= \q -&gt; divo (inject' 12) m q (inject' 0))
--   [Just [O,O,I,I],Just [I],Just [I,I],Just [O,I,I],Just [O,I],Just [O,O,I]]
--   </pre>
--   
--   The implementation of <tt>div</tt> is discussed in section 6 of the
--   paper.
divo :: Term Binary -> Term Binary -> Term Binary -> Term Binary -> Goal ()

-- | Calculate discrete logarithm <tt>q</tt> of a number <tt>n</tt> in base
--   <tt>b</tt>, perhaps with some remainder <tt>r</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; bimap extract' extract' &lt;$&gt; run (\(q, r) -&gt; logo (inject' 9) (inject' 3) q r)
--   [(Just [O,I],Just [])]
--   
--   &gt;&gt;&gt; bimap extract' extract' &lt;$&gt; run (\(q, r) -&gt; logo (inject' 15) (inject' 3) q r)
--   [(Just [O,I],Just [0,I,I])]
--   </pre>
--   
--   One can turn this around to find the number <tt>b</tt> raised to some
--   power <tt>q</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (\n -&gt; logo n (inject' 5) (inject' 2) (inject' 0))
--   [Just [I,O,O,I,I]]
--   </pre>
--   
--   or to find the <tt>q</tt>-th root of <tt>n</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; extract' &lt;$&gt; run (\b -&gt; logo (inject' 8) b (inject' 3) (inject' 0))
--   [Just [O,I]]
--   </pre>
--   
--   If you want to enumerate solutions to <tt>logo n b q r</tt>, you
--   probably shouldn't go beyond the first 16 solutions without an OOM
--   killer.
--   
--   The original implementation of this relation in Prolog can be found at
--   <a>https://okmij.org/ftp/Prolog/Arithm/pure-bin-arithm.prl</a>.
--   Although the paper mentions this relation in section 6, it does not
--   discuss its implementation in detail.
logo :: Term Binary -> Term Binary -> Term Binary -> Term Binary -> Goal ()
example :: IO ()
instance GHC.Num.Num Kanren.Data.Binary.Binary
instance Control.DeepSeq.NFData Kanren.Data.Binary.Bit
instance GHC.Generics.Generic Kanren.Data.Binary.Bit
instance GHC.Show.Show Kanren.Data.Binary.Bit
instance GHC.Classes.Eq Kanren.Data.Binary.Bit
instance Kanren.Core.Logical Kanren.Data.Binary.Bit
